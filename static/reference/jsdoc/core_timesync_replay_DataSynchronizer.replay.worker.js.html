<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/timesync/replay/DataSynchronizer.replay.worker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>
<div class="container">
    <nav>
        <h2><a href="index.html">OSH-JS</a></h2><h3>Modules</h3><ul><li><a href="module-osh-vue_MenuSettings.html">osh-vue/MenuSettings</a></li><li><a href="module-osh-vue_TimeController.html">osh-vue/TimeController</a></li><li><a href="module-Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="AnimationObjectGroup.html">AnimationObjectGroup</a></li><li><a href="AudioCanvasVisualizer.html">AudioCanvasVisualizer</a></li><li><a href="AudioChartVisualizer.html">AudioChartVisualizer</a></li><li><a href="AudioDataLayer.html">AudioDataLayer</a></li><li><a href="AudioFrequencyCanvasVisualizer.html">AudioFrequencyCanvasVisualizer</a></li><li><a href="AudioFrequencyChartJsVisualizer.html">AudioFrequencyChartJsVisualizer</a></li><li><a href="AudioSpectrogramVisualizer.html">AudioSpectrogramVisualizer</a></li><li><a href="AudioTimeCanvasVisualizer.html">AudioTimeCanvasVisualizer</a></li><li><a href="AudioTimeChartJsVisualizer.html">AudioTimeChartJsVisualizer</a></li><li><a href="AudioView.html">AudioView</a></li><li><a href="AudioVisualizer.html">AudioVisualizer</a></li><li><a href="BinaryDataLayer.html">BinaryDataLayer</a></li><li><a href="BooleanKeyframeTrack.html">BooleanKeyframeTrack</a></li><li><a href="CameraHelper.html">CameraHelper</a></li><li><a href="CanvasView.html">CanvasView</a></li><li><a href="CesiumView.html">CesiumView</a></li><li><a href="ChartJsView.html">ChartJsView</a></li><li><a href="Collection.html">Collection</a></li><li><a href="ColorKeyframeTrack.html">ColorKeyframeTrack</a></li><li><a href="Command.html">Command</a></li><li><a href="CommandFilter.html">CommandFilter</a></li><li><a href="Commands.html">Commands</a></li><li><a href="CompressedTextureLoader.html">CompressedTextureLoader</a></li><li><a href="ConnectedSystemsApi.html">ConnectedSystemsApi</a></li><li><a href="ConSysApi.html">ConSysApi</a></li><li><a href="Control.html">Control</a></li><li><a href="ControlFilter.html">ControlFilter</a></li><li><a href="Controls.html">Controls</a></li><li><a href="ControlStream.html">ControlStream</a></li><li><a href="ControlStreamFilter.html">ControlStreamFilter</a></li><li><a href="ControlStreams.html">ControlStreams</a></li><li><a href="CoPlanarPolygonLayer.html">CoPlanarPolygonLayer</a></li><li><a href="CubicInterpolant.html">CubicInterpolant</a></li><li><a href="Curve.html">Curve</a></li><li><a href="CurveLayer.html">CurveLayer</a></li><li><a href="Cylindrical.html">Cylindrical</a></li><li><a href="DataConnector.html">DataConnector</a></li><li><a href="DataSenderController.html">DataSenderController</a></li><li><a href="DataSink.html">DataSink</a></li><li><a href="DataStream.html">DataStream</a></li><li><a href="DataStreamFilter.html">DataStreamFilter</a></li><li><a href="DataStreams.html">DataStreams</a></li><li><a href="DataSynchronizer.html">DataSynchronizer</a></li><li><a href="DataSynchronizerBatch.html">DataSynchronizerBatch</a></li><li><a href="DataSynchronizerRealtime.html">DataSynchronizerRealtime</a></li><li><a href="DataSynchronizerReplay.html">DataSynchronizerReplay</a></li><li><a href="DataTextureLoader.html">DataTextureLoader</a></li><li><a href="DeckGlView.html">DeckGlView</a></li><li><a href="DiscreteInterpolant.html">DiscreteInterpolant</a></li><li><a href="EllipseLayer.html">EllipseLayer</a></li><li><a href="Event.html">Event</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="EventFilter.html">EventFilter</a></li><li><a href="Events.html">Events</a></li><li><a href="ExtrudeGeometry.html">ExtrudeGeometry</a></li><li><a href="FeatureOfInterest.html">FeatureOfInterest</a></li><li><a href="FeatureOfInterestFilter.html">FeatureOfInterestFilter</a></li><li><a href="FeaturesOfInterest.html">FeaturesOfInterest</a></li><li><a href="FFMPEGView.html">FFMPEGView</a></li><li><a href="FileConnector.html">FileConnector</a></li><li><a href="FileDataSource.html">FileDataSource</a></li><li><a href="FoscamPtzTasking.html">FoscamPtzTasking</a></li><li><a href="frustumLayer.html">frustumLayer</a></li><li><a href="HttpConnector.html">HttpConnector</a></li><li><a href="ImageDrapingLayer.html">ImageDrapingLayer</a></li><li><a href="Interpolant.html">Interpolant</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LeafletView.html">LeafletView</a></li><li><a href="LineBasicMaterial.html">LineBasicMaterial</a></li><li><a href="LineDashedMaterial.html">LineDashedMaterial</a></li><li><a href="MapboxView.html">MapboxView</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MeshBasicMaterial.html">MeshBasicMaterial</a></li><li><a href="MeshDepthMaterial.html">MeshDepthMaterial</a></li><li><a href="MeshDistanceMaterial.html">MeshDistanceMaterial</a></li><li><a href="MeshLambertMaterial.html">MeshLambertMaterial</a></li><li><a href="MeshMatcapMaterial.html">MeshMatcapMaterial</a></li><li><a href="MeshNormalMaterial.html">MeshNormalMaterial</a></li><li><a href="MeshPhongMaterial.html">MeshPhongMaterial</a></li><li><a href="MeshPhysicalMaterial.html">MeshPhysicalMaterial</a></li><li><a href="MeshStandardMaterial.html">MeshStandardMaterial</a></li><li><a href="MeshToonMaterial.html">MeshToonMaterial</a></li><li><a href="MjpegView.html">MjpegView</a></li><li><a href="MqttConnector.html">MqttConnector</a></li><li><a href="MqttProvider.html">MqttProvider</a></li><li><a href="MqttTopicConnector.html">MqttTopicConnector</a></li><li><a href="NumberKeyframeTrack.html">NumberKeyframeTrack</a></li><li><a href="Observation.html">Observation</a></li><li><a href="ObservationFilter.html">ObservationFilter</a></li><li><a href="Observations.html">Observations</a></li><li><a href="ObservationsCollection.html">ObservationsCollection</a></li><li><a href="OpenLayerView.html">OpenLayerView</a></li><li><a href="ParametricGeometry.html">ParametricGeometry</a></li><li><a href="PointMarkerLayer.html">PointMarkerLayer</a></li><li><a href="PointsMaterial.html">PointsMaterial</a></li><li><a href="PolygonLayer.html">PolygonLayer</a></li><li><a href="PolylineLayer.html">PolylineLayer</a></li><li><a href="PtzTasking.html">PtzTasking</a></li><li><a href="QuaternionKeyframeTrack.html">QuaternionKeyframeTrack</a></li><li><a href="QuaternionLinearInterpolant.html">QuaternionLinearInterpolant</a></li><li><a href="RangeSliderViewRealtime.html">RangeSliderViewRealtime</a></li><li><a href="RangeSliderViewReplay.html">RangeSliderViewReplay</a></li><li><a href="SamplingFeature.html">SamplingFeature</a></li><li><a href="SamplingFeatureFilter.html">SamplingFeatureFilter</a></li><li><a href="SamplingFeatures.html">SamplingFeatures</a></li><li><a href="SensorWebApi.html">SensorWebApi</a></li><li><a href="Server.html">Server</a></li><li><a href="ShaderMaterial.html">ShaderMaterial</a></li><li><a href="ShadowMaterial.html">ShadowMaterial</a></li><li><a href="SosGetResult.html">SosGetResult</a></li><li><a href="SpectrogramView.html">SpectrogramView</a></li><li><a href="Spherical.html">Spherical</a></li><li><a href="SphericalHarmonics3.html">SphericalHarmonics3</a></li><li><a href="SpriteMaterial.html">SpriteMaterial</a></li><li><a href="StringKeyframeTrack.html">StringKeyframeTrack</a></li><li><a href="SweApi.html">SweApi</a></li><li><a href="SWEXmlStreamParser.html">SWEXmlStreamParser</a></li><li><a href="System.html">System</a></li><li><a href="SystemFilter.html">SystemFilter</a></li><li><a href="SystemHistoryFilter.html">SystemHistoryFilter</a></li><li><a href="Systems.html">Systems</a></li><li><a href="TextGeometry.html">TextGeometry</a></li><li><a href="TimeSeriesDatasource.html">TimeSeriesDatasource</a></li><li><a href="TimeSeriesReplayDatasource.html">TimeSeriesReplayDatasource</a></li><li><a href="TopicConnector.html">TopicConnector</a></li><li><a href="UavMapTasking.html">UavMapTasking</a></li><li><a href="VectorKeyframeTrack.html">VectorKeyframeTrack</a></li><li><a href="VideoDataLayer.html">VideoDataLayer</a></li><li><a href="VideoView.html">VideoView</a></li><li><a href="View.html">View</a></li><li><a href="WebCodecView.html">WebCodecView</a></li><li><a href="WebSocketConnector.html">WebSocketConnector</a></li><li><a href="WebSocketFetchConnector.html">WebSocketFetchConnector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addDataSources">addDataSources</a></li><li><a href="global.html#CatmullRom">CatmullRom</a></li><li><a href="global.html#cloneUniforms">cloneUniforms</a></li><li><a href="global.html#convertLinearToRGBE">convertLinearToRGBE</a></li><li><a href="global.html#Earcut">Earcut</a></li><li><a href="global.html#ECEF_WITH_MATRICES">ECEF_WITH_MATRICES</a></li><li><a href="global.html#ECEF_WITH_QUATERNIONS">ECEF_WITH_QUATERNIONS</a></li><li><a href="global.html#emptyTexture">emptyTexture</a></li><li><a href="global.html#FrustumPositionMode">FrustumPositionMode</a></li><li><a href="global.html#GimbalEulerAngleOrder">GimbalEulerAngleOrder</a></li><li><a href="global.html#ImageDrapingPositionMode">ImageDrapingPositionMode</a></li><li><a href="global.html#initialStates">initialStates</a></li><li><a href="global.html#LONLATALT_WITH_EULER_ANGLES">LONLATALT_WITH_EULER_ANGLES</a></li><li><a href="global.html#maxPoolSize">maxPoolSize</a></li><li><a href="global.html#Mode">Mode</a></li><li><a href="global.html#mqttConnectors">mqttConnectors</a></li><li><a href="global.html#mqttProviders">mqttProviders</a></li><li><a href="global.html#reconnectionInterval">reconnectionInterval</a></li><li><a href="global.html#removeDataSources">removeDataSources</a></li><li><a href="global.html#REVISION">REVISION</a></li><li><a href="global.html#Status">Status</a></li><li><a href="global.html#UniformsLib">UniformsLib</a></li></ul>
    </nav>
    <div id="main">

        <h1 class="page-title">Source: core/timesync/replay/DataSynchronizer.replay.worker.js</h1>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {DATASOURCE_DATA_TOPIC} from "../../Constants.js";
import {EventType} from "../../event/EventType.js";
import {isDefined} from "../../utils/Utils";
import DataSynchronizerAlgoReplay from "./DataSynchronizerAlgo.replay";

const bcChannels = {};
let dataSynchronizerAlgo;

let init = false;
let dataSynchronizerBroadCastChannel = null;
let lastData = undefined;
const dataSources = {};
let timeBroadcastChannel = null;
let topicTime;
let topicData;
let replaySpeed;
let masterTimeInterval = undefined;
let cTime;
let cId;
let lastTime = -1;
let version = -1;
let promise;
let masterTimeRefreshRate;
let startTimestamp;
let endTimestamp;
let timerResolution;

self.onmessage = async (event) => {
    handleMessage(event);
}

async function handleMessage(event) {
    let resp = {};
    if (event.data.ackId) {
        resp.ackId = event.data.ackId;
    }

    let data = undefined;
    try {
        if (event.data.message === 'init') {
            replaySpeed = event.data.replaySpeed;
            startTimestamp = event.data.startTimestamp;
            endTimestamp = event.data.endTimestamp;
            version = event.data.version;
            timerResolution = event.data.timerResolution;

            dataSynchronizerAlgo = new DataSynchronizerAlgoReplay(
                event.data.dataSources,
                replaySpeed,
                startTimestamp,
                endTimestamp,
                event.data.timerResolution,
                version
            );
            dataSynchronizerAlgo.onClose = onClose;
            dataSynchronizerAlgo.onData = onData;
            init = true;
            addDataSources(event.data.dataSources);
            topicData = event.data.topics.data;
            topicTime = event.data.topics.time;
            initBroadcastChannel(topicData, topicTime);
            masterTimeRefreshRate = event.data.masterTimeRefreshRate;
        } else if (event.data.message === 'add' &amp;&amp; event.data.dataSources) {
            console.log('Add datasource to synchronizer..')
            addDataSources(event.data.dataSources);
            if (dataSynchronizerAlgo instanceof DataSynchronizerAlgoReplay) {
                dataSynchronizerAlgo.startTimestamp = event.data.startTimestamp;
                dataSynchronizerAlgo.endTimestamp = event.data.endTimestamp;
            }
            reset();
        } else if (event.data.message === 'connect') {
            startMasterTimeInterval(masterTimeRefreshRate);
            dataSynchronizerAlgo.checkStart();
            version = event.data.version;
        } else if (event.data.message === 'is-connected') {
            data = isDefined(masterTimeInterval) &amp;&amp; isDefined(dataSynchronizerAlgo) &amp;&amp; isDefined(dataSynchronizerAlgo.interval);
        } else if (event.data.message === 'remove') {
            console.log('Remove datasource from synchronizer algorithm..')
            await removeDataSources(event.data.dataSourceIds);
            if (dataSynchronizerAlgo instanceof DataSynchronizerAlgoReplay) {
                dataSynchronizerAlgo.startTimestamp = event.data.startTimestamp;
                dataSynchronizerAlgo.endTimestamp = event.data.endTimestamp;
            }
            reset();
        } else if (event.data.message === 'current-time') {
            data = dataSynchronizerAlgo.getCurrentTimestamp();
        } else if (event.data.message === 'reset') {
            reset();
        } else if (event.data.message === 'replay-speed') {
            if (dataSynchronizerAlgo !== null) {
                reset();
                dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;
            }
        } else if (event.data.message === 'set-max-time') {
            dataSynchronizerAlgo.setEndTimestamp(event.data.maxTimestamp);
        } else if (event.data.message === 'time-range') {
            setTimeRange(
                event.data.startTimestamp,
                event.data.endTimestamp,
                event.data.mode,
                event.data.replaySpeed,
                event.data.version,
                event.data.dataSources
            )
        } else if (event.data.message === 'data') {
            checkMasterTime();
            if (dataSynchronizerAlgo !== null) {
                dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);
            }
        }
    } catch (ex) {
        console.error(ex);
        resp.error = ex;
    } finally {
        resp.data = data;
        self.postMessage(resp);
    }
}
function setTimeRange(startTimestamp, endTimestamp, mode, replaySpeed, newVersion, dsArray) {
    reset();
    version = newVersion;

    dataSynchronizerAlgo = new DataSynchronizerAlgoReplay(
        dsArray,
        replaySpeed,
        startTimestamp,
        endTimestamp,
        timerResolution,
        version
    );
    dataSynchronizerAlgo.onEnd = onEnd;
    dataSynchronizerAlgo.onStart = onStart;
    dataSynchronizerAlgo.onClose = onClose;
    dataSynchronizerAlgo.onData = onData;
}
function reset() {
    clearInterval(masterTimeInterval);
    masterTimeInterval = undefined;
    if(dataSynchronizerAlgo !== null) {
        dataSynchronizerAlgo.reset();
    }
    timeBroadcastChannel.postMessage({
        type: EventType.TIME_CHANGED
    });
    timeBroadcastChannel.postMessage({
        type: EventType.CLOSED
    });

    dataSynchronizerBroadCastChannel.postMessage({
        type: EventType.STATUS,
        status: 'not_running',
    });
}
function initBroadcastChannel(dataTopic, timeTopic) {
    console.log('listen on topic ',dataTopic)

    dataSynchronizerBroadCastChannel = new BroadcastChannel(dataTopic);
    dataSynchronizerBroadCastChannel.onmessage = async (event) => {
        if(event.data.type === EventType.DATA) {
            checkMasterTime();
            dataSynchronizerAlgo.push(event.data.dataSourceId,event.data.values);
        } else if(event.data.type === EventType.STATUS) {
            const dataSourceId = event.data.dataSourceId;
            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);
            // bubble the message
            if(dataSourceId in bcChannels) {
                console.log(dataSources[dataSourceId].name + ": status=" + event.data.status);
                bcChannels[dataSourceId].postMessage(event.data);
            }
        }
    }

    timeBroadcastChannel = new BroadcastChannel(timeTopic);

}

/**
 *
 * @param dataSources
 */
function addDataSources(dataSources) {
    for(let dataSource of dataSources) {
        addDataSource(dataSource);
    }
}

function addDataSource(dataSource) {
    dataSynchronizerAlgo.addDataSource(dataSource);
    // create a BC to push back the synchronized data into the DATA Stream.
    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);

    if(!(dataSource.id in dataSources)) {
        dataSources[dataSource.id] = dataSource;
    }
}

/**
 *
 * @param dataSourceIds
 */
function removeDataSources(dataSourceIds) {
    for(let dataSourceId of dataSourceIds) {
        removeDataSource(dataSourceId);
    }
}

function removeDataSource(dataSourceId) {
    dataSynchronizerAlgo.removeDataSource(dataSourceId);
    // create a BC to push back the synchronized data into the DATA Stream.
    console.log('deleting BC for datasource '+dataSourceId);
    delete bcChannels[dataSourceId];
    delete dataSources[dataSourceId];
}

function checkMasterTime() {
    if(!isDefined(masterTimeInterval)) {
        startMasterTimeInterval(masterTimeRefreshRate);
    }
}
async function onEnd() {
    const masterTime = dataSynchronizerAlgo.getCurrentTimestamp();
    clearInterval(masterTimeInterval);
    masterTimeInterval = undefined;
    // end at this time
    timeBroadcastChannel.postMessage({
        timestamp: masterTime,
        type: EventType.MASTER_TIME
    });
    dataSynchronizerBroadCastChannel.postMessage({
        type: EventType.STATUS,
        status: 'not_running',
    });
}

async function onStart() {
    checkMasterTime();
}

function onClose() {
    timeBroadcastChannel.postMessage({
        type: EventType.CLOSED
    });
    dataSynchronizerBroadCastChannel.postMessage({
        type: EventType.STATUS,
        status: 'not_running',
    });
}

async function onData(dataSourceId, dataBlock) {
    if(dataBlock.version !== version) {
        console.error('version are different:',dataBlock.version,version);
        return;
    }
    lastData = {
        dataSourceId: dataSourceId,
        dataBlock: dataBlock,
    };
    bcChannels[dataSourceId].postMessage({
            values: [dataBlock],
            dataSourceId:dataSourceId,
            type: EventType.DATA
        }
    );
}
self.onclose = function() {
    dataSynchronizerAlgo.close();
    console.log("Data Synchronizer has been terminated successfully");
    dataSynchronizerBroadCastChannel.postMessage({
        type: EventType.STATUS,
        status: 'not_running',
    });
}

let masterTime;
function startMasterTimeInterval(masterTimeRefreshRate) {
    if (!isDefined(masterTimeInterval)) {
        masterTimeInterval = setInterval(() => {
            masterTime = dataSynchronizerAlgo.getCurrentTimestamp();
            if (isDefined(masterTime)) {
                timeBroadcastChannel.postMessage({
                    timestamp: masterTime,
                    type: EventType.MASTER_TIME
                });
            }

            if(isDefined(lastData)) {
                cTime = lastData.dataBlock.data.timestamp;
                cId = lastData.dataSourceId;

                if ((cTime !== -1 &amp;&amp; lastTime === -1) || (lastTime !== -1 &amp;&amp; cTime !== lastTime)) { // does not send the same data twice
                    timeBroadcastChannel.postMessage({
                        timestamp: cTime,
                        dataSourceId: cId,
                        type: EventType.LAST_TIME
                    });
                }
                lastTime = cTime;
            }
        }, masterTimeRefreshRate);
        dataSynchronizerBroadCastChannel.postMessage({
            type: EventType.STATUS,
            status: 'running',
        });
    }
}
</code></pre>
        </article>
    </section>




    </div>
</div>


<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
