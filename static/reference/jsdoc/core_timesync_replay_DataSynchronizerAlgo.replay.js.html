<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/timesync/replay/DataSynchronizerAlgo.replay.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>
<div class="container">
    <nav>
        <h2><a href="index.html">OSH-JS</a></h2><h3>Modules</h3><ul><li><a href="module-osh-vue_MenuSettings.html">osh-vue/MenuSettings</a></li><li><a href="module-osh-vue_TimeController.html">osh-vue/TimeController</a></li><li><a href="module-Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="AnimationObjectGroup.html">AnimationObjectGroup</a></li><li><a href="AudioCanvasVisualizer.html">AudioCanvasVisualizer</a></li><li><a href="AudioChartVisualizer.html">AudioChartVisualizer</a></li><li><a href="AudioDataLayer.html">AudioDataLayer</a></li><li><a href="AudioFrequencyCanvasVisualizer.html">AudioFrequencyCanvasVisualizer</a></li><li><a href="AudioFrequencyChartJsVisualizer.html">AudioFrequencyChartJsVisualizer</a></li><li><a href="AudioSpectrogramVisualizer.html">AudioSpectrogramVisualizer</a></li><li><a href="AudioTimeCanvasVisualizer.html">AudioTimeCanvasVisualizer</a></li><li><a href="AudioTimeChartJsVisualizer.html">AudioTimeChartJsVisualizer</a></li><li><a href="AudioView.html">AudioView</a></li><li><a href="AudioVisualizer.html">AudioVisualizer</a></li><li><a href="BinaryDataLayer.html">BinaryDataLayer</a></li><li><a href="BooleanKeyframeTrack.html">BooleanKeyframeTrack</a></li><li><a href="CameraHelper.html">CameraHelper</a></li><li><a href="CanvasView.html">CanvasView</a></li><li><a href="CesiumView.html">CesiumView</a></li><li><a href="ChartJsView.html">ChartJsView</a></li><li><a href="Collection.html">Collection</a></li><li><a href="ColorKeyframeTrack.html">ColorKeyframeTrack</a></li><li><a href="Command.html">Command</a></li><li><a href="CommandFilter.html">CommandFilter</a></li><li><a href="Commands.html">Commands</a></li><li><a href="CompressedTextureLoader.html">CompressedTextureLoader</a></li><li><a href="ConnectedSystemsApi.html">ConnectedSystemsApi</a></li><li><a href="ConSysApi.html">ConSysApi</a></li><li><a href="Control.html">Control</a></li><li><a href="ControlFilter.html">ControlFilter</a></li><li><a href="Controls.html">Controls</a></li><li><a href="ControlStream.html">ControlStream</a></li><li><a href="ControlStreamFilter.html">ControlStreamFilter</a></li><li><a href="ControlStreams.html">ControlStreams</a></li><li><a href="CoPlanarPolygonLayer.html">CoPlanarPolygonLayer</a></li><li><a href="CubicInterpolant.html">CubicInterpolant</a></li><li><a href="Curve.html">Curve</a></li><li><a href="CurveLayer.html">CurveLayer</a></li><li><a href="Cylindrical.html">Cylindrical</a></li><li><a href="DataConnector.html">DataConnector</a></li><li><a href="DataSenderController.html">DataSenderController</a></li><li><a href="DataSink.html">DataSink</a></li><li><a href="DataStream.html">DataStream</a></li><li><a href="DataStreamFilter.html">DataStreamFilter</a></li><li><a href="DataStreams.html">DataStreams</a></li><li><a href="DataSynchronizer.html">DataSynchronizer</a></li><li><a href="DataSynchronizerBatch.html">DataSynchronizerBatch</a></li><li><a href="DataSynchronizerRealtime.html">DataSynchronizerRealtime</a></li><li><a href="DataSynchronizerReplay.html">DataSynchronizerReplay</a></li><li><a href="DataTextureLoader.html">DataTextureLoader</a></li><li><a href="DeckGlView.html">DeckGlView</a></li><li><a href="DiscreteInterpolant.html">DiscreteInterpolant</a></li><li><a href="EllipseLayer.html">EllipseLayer</a></li><li><a href="Event.html">Event</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="EventFilter.html">EventFilter</a></li><li><a href="Events.html">Events</a></li><li><a href="ExtrudeGeometry.html">ExtrudeGeometry</a></li><li><a href="FeatureOfInterest.html">FeatureOfInterest</a></li><li><a href="FeatureOfInterestFilter.html">FeatureOfInterestFilter</a></li><li><a href="FeaturesOfInterest.html">FeaturesOfInterest</a></li><li><a href="FFMPEGView.html">FFMPEGView</a></li><li><a href="FileConnector.html">FileConnector</a></li><li><a href="FileDataSource.html">FileDataSource</a></li><li><a href="FoscamPtzTasking.html">FoscamPtzTasking</a></li><li><a href="frustumLayer.html">frustumLayer</a></li><li><a href="HttpConnector.html">HttpConnector</a></li><li><a href="ImageDrapingLayer.html">ImageDrapingLayer</a></li><li><a href="Interpolant.html">Interpolant</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LeafletView.html">LeafletView</a></li><li><a href="LineBasicMaterial.html">LineBasicMaterial</a></li><li><a href="LineDashedMaterial.html">LineDashedMaterial</a></li><li><a href="MapboxView.html">MapboxView</a></li><li><a href="MapView.html">MapView</a></li><li><a href="MeshBasicMaterial.html">MeshBasicMaterial</a></li><li><a href="MeshDepthMaterial.html">MeshDepthMaterial</a></li><li><a href="MeshDistanceMaterial.html">MeshDistanceMaterial</a></li><li><a href="MeshLambertMaterial.html">MeshLambertMaterial</a></li><li><a href="MeshMatcapMaterial.html">MeshMatcapMaterial</a></li><li><a href="MeshNormalMaterial.html">MeshNormalMaterial</a></li><li><a href="MeshPhongMaterial.html">MeshPhongMaterial</a></li><li><a href="MeshPhysicalMaterial.html">MeshPhysicalMaterial</a></li><li><a href="MeshStandardMaterial.html">MeshStandardMaterial</a></li><li><a href="MeshToonMaterial.html">MeshToonMaterial</a></li><li><a href="MjpegView.html">MjpegView</a></li><li><a href="MqttConnector.html">MqttConnector</a></li><li><a href="MqttProvider.html">MqttProvider</a></li><li><a href="MqttTopicConnector.html">MqttTopicConnector</a></li><li><a href="NumberKeyframeTrack.html">NumberKeyframeTrack</a></li><li><a href="Observation.html">Observation</a></li><li><a href="ObservationFilter.html">ObservationFilter</a></li><li><a href="Observations.html">Observations</a></li><li><a href="ObservationsCollection.html">ObservationsCollection</a></li><li><a href="OpenLayerView.html">OpenLayerView</a></li><li><a href="ParametricGeometry.html">ParametricGeometry</a></li><li><a href="PointMarkerLayer.html">PointMarkerLayer</a></li><li><a href="PointsMaterial.html">PointsMaterial</a></li><li><a href="PolygonLayer.html">PolygonLayer</a></li><li><a href="PolylineLayer.html">PolylineLayer</a></li><li><a href="PtzTasking.html">PtzTasking</a></li><li><a href="QuaternionKeyframeTrack.html">QuaternionKeyframeTrack</a></li><li><a href="QuaternionLinearInterpolant.html">QuaternionLinearInterpolant</a></li><li><a href="RangeSliderViewRealtime.html">RangeSliderViewRealtime</a></li><li><a href="RangeSliderViewReplay.html">RangeSliderViewReplay</a></li><li><a href="SamplingFeature.html">SamplingFeature</a></li><li><a href="SamplingFeatureFilter.html">SamplingFeatureFilter</a></li><li><a href="SamplingFeatures.html">SamplingFeatures</a></li><li><a href="SensorWebApi.html">SensorWebApi</a></li><li><a href="Server.html">Server</a></li><li><a href="ShaderMaterial.html">ShaderMaterial</a></li><li><a href="ShadowMaterial.html">ShadowMaterial</a></li><li><a href="SosGetResult.html">SosGetResult</a></li><li><a href="SpectrogramView.html">SpectrogramView</a></li><li><a href="Spherical.html">Spherical</a></li><li><a href="SphericalHarmonics3.html">SphericalHarmonics3</a></li><li><a href="SpriteMaterial.html">SpriteMaterial</a></li><li><a href="StringKeyframeTrack.html">StringKeyframeTrack</a></li><li><a href="SweApi.html">SweApi</a></li><li><a href="SWEXmlStreamParser.html">SWEXmlStreamParser</a></li><li><a href="System.html">System</a></li><li><a href="SystemFilter.html">SystemFilter</a></li><li><a href="SystemHistoryFilter.html">SystemHistoryFilter</a></li><li><a href="Systems.html">Systems</a></li><li><a href="TextGeometry.html">TextGeometry</a></li><li><a href="TimeSeriesDatasource.html">TimeSeriesDatasource</a></li><li><a href="TimeSeriesReplayDatasource.html">TimeSeriesReplayDatasource</a></li><li><a href="TopicConnector.html">TopicConnector</a></li><li><a href="UavMapTasking.html">UavMapTasking</a></li><li><a href="VectorKeyframeTrack.html">VectorKeyframeTrack</a></li><li><a href="VideoDataLayer.html">VideoDataLayer</a></li><li><a href="VideoView.html">VideoView</a></li><li><a href="View.html">View</a></li><li><a href="WebCodecView.html">WebCodecView</a></li><li><a href="WebSocketConnector.html">WebSocketConnector</a></li><li><a href="WebSocketFetchConnector.html">WebSocketFetchConnector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addDataSources">addDataSources</a></li><li><a href="global.html#CatmullRom">CatmullRom</a></li><li><a href="global.html#cloneUniforms">cloneUniforms</a></li><li><a href="global.html#convertLinearToRGBE">convertLinearToRGBE</a></li><li><a href="global.html#Earcut">Earcut</a></li><li><a href="global.html#ECEF_WITH_MATRICES">ECEF_WITH_MATRICES</a></li><li><a href="global.html#ECEF_WITH_QUATERNIONS">ECEF_WITH_QUATERNIONS</a></li><li><a href="global.html#emptyTexture">emptyTexture</a></li><li><a href="global.html#FrustumPositionMode">FrustumPositionMode</a></li><li><a href="global.html#GimbalEulerAngleOrder">GimbalEulerAngleOrder</a></li><li><a href="global.html#ImageDrapingPositionMode">ImageDrapingPositionMode</a></li><li><a href="global.html#initialStates">initialStates</a></li><li><a href="global.html#LONLATALT_WITH_EULER_ANGLES">LONLATALT_WITH_EULER_ANGLES</a></li><li><a href="global.html#maxPoolSize">maxPoolSize</a></li><li><a href="global.html#Mode">Mode</a></li><li><a href="global.html#mqttConnectors">mqttConnectors</a></li><li><a href="global.html#mqttProviders">mqttProviders</a></li><li><a href="global.html#reconnectionInterval">reconnectionInterval</a></li><li><a href="global.html#removeDataSources">removeDataSources</a></li><li><a href="global.html#REVISION">REVISION</a></li><li><a href="global.html#Status">Status</a></li><li><a href="global.html#UniformsLib">UniformsLib</a></li></ul>
    </nav>
    <div id="main">

        <h1 class="page-title">Source: core/timesync/replay/DataSynchronizerAlgo.replay.js</h1>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {isDefined} from "../../utils/Utils.js";
import {Status} from "../../connector/Status.js";
import DataSynchronizerAlgo from "../DataSynchronizerAlgo";

class DataSynchronizerAlgoReplay extends DataSynchronizerAlgo {
    constructor(dataSources, replaySpeed = 1, startTimestamp, endTimestamp, timerResolution = 5, version) {
        super(dataSources,replaySpeed,timerResolution);
        this.replaySpeed = replaySpeed;
        this.startTimestamp = startTimestamp;
        this.endTimestamp = endTimestamp;
        this.version = version;
    }

    push(dataSourceId, dataBlocks) {
        if(dataBlocks.length === 0) {
            return;
        }
        if(dataSourceId in this.dataSourceMap) {
            const ds = this.dataSourceMap[dataSourceId];
            const lastData = dataBlocks[dataBlocks.length - 1];
            if (!this.checkVersion(lastData)) {
                console.warn(`[DataSynchronizer] incompatible version ${lastData.version} ~ ${this.version}, skipping data`);
                return;
            }
            ds.dataBuffer.push(...dataBlocks);
        }
    }

    processData() {
        this.clockTimeRef = performance.now();

        this.interval = setInterval(() => {
            // 1) return the oldest data if any
            while (this.computeNextData(this.startTimestamp, this.clockTimeRef )) {
                this.checkEnd();
            }
            this.checkEnd();
        }, this.timerResolution);
        console.warn(`Started Replay Algorithm with tsRef=${new Date(this.startTimestamp).toISOString()}`);
    }

    /**
     * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,
     * we return only the oldest one.
     * @param tsRef - the timestamp of the first data
     * @param refClockTime - the absolute diff time really spent
     */
    computeNextData(tsRef, refClockTime) {
        try {
            let currentDs;
            let currentDsToShift = null;

            const dClock = (performance.now() - refClockTime) * this.replaySpeed;
            let tsRun = tsRef + dClock;

            let computeNext = false;
            // compute next data to return
            for (let currentDsId in this.dataSourceMap) {
                currentDs = this.dataSourceMap[currentDsId];
                if (currentDs.skip) {
                    // if datasource is in current range
                    if (tsRun > currentDs.minTimestamp &amp;&amp; tsRun &lt; currentDs.maxTimestamp) {
                        currentDs.skip = false;
                    }
                }
                // skip DatSource if out of time range
                if (currentDs.skip) continue;
                if (currentDs.dataBuffer.length > 0) {
                    const dTs = (currentDs.dataBuffer[0].data.timestamp - tsRef);
                    // we use an intermediate object to store the data to shift because we want to return the oldest one
                    // only
                    if (dTs &lt;= dClock) {
                        // no other one to compare
                        if (currentDsToShift === null) {
                            currentDsToShift = currentDs;
                        } else {
                            // take the oldest data
                            currentDsToShift = (currentDsToShift.dataBuffer[0].data.timestamp &lt; currentDs.dataBuffer[0].data.timestamp) ?
                                currentDsToShift : currentDs;
                        }
                    }
                }
            }

            // finally pop the data from DS queue
            if (currentDsToShift !== null) {
                if (currentDsToShift.id in this.dataSourceMap) {
                    this.onData(currentDsToShift.id, currentDsToShift.dataBuffer.shift());
                }
                computeNext = true;
            }
            this.tsRun = tsRun;
            return computeNext;
        } catch (ex) {
            console.log(ex);
            return false;
        }
    }

    /**
     * Add dataSource to be synchronized
     * @param {Datasource} dataSource - the dataSource to synchronize
     */
    addDataSource(dataSource) {
        this.dataSourceMap[dataSource.id] = {
            dataBuffer: [],
            id: dataSource.id,
            name: dataSource.name || dataSource.id,
            status: Status.DISCONNECTED, //MEANING Enabled, 0 = Disabled
            minTimestamp: dataSource.minTimestamp,
            maxTimestamp: dataSource.maxTimestamp,
            skip: false
        };
        if(dataSource.maxTimestamp &lt; this.getCurrentTimestamp() || dataSource.minTimestamp > this.getCurrentTimestamp()) {
            this.dataSourceMap[dataSource.id].skip = true;
            console.warn(`Skipping new added dataSource ${dataSource.id} because timeRange of the dataSource is not intersecting the synchronizer one`);
        }
        this.datasources.push(dataSource);
    }

    checkVersion(dataBlock) {
        return (dataBlock.version === this.version);
    }

    /**
     * Change the dataSource status
     * @param {Status} status - the new status
     * @param {String} dataSourceId - the corresponding dataSource id
     */
    setStatus(dataSourceId, status) {
        if (dataSourceId in this.dataSourceMap) {
            this.dataSourceMap[dataSourceId].status = status;
            console.warn(status+' DataSource ' + dataSourceId + ' from the synchronizer ');
        }
        this.checkStart();
    }

    checkStart() {
        if(!isDefined(this.interval)) {
            let nbSkip = 0;
            let nbFetch = 0
            let totalDataSources = Object.keys(this.dataSourceMap).length;

            if(totalDataSources === 0) {
                return;
            }
            let dataSource;
            for(let dataSourceID in this.dataSourceMap) {
                dataSource = this.dataSourceMap[dataSourceID];
                dataSource.skip = (this.startTimestamp &lt; dataSource.minTimestamp) || (this.startTimestamp > dataSource.maxTimestamp);
                if(dataSource.status === Status.FETCH_STARTED){
                    nbFetch++;
                } else if(dataSource.skip) {
                    nbSkip++;
                }
            }

            console.warn(`[Synchronizer] Fetched ${nbFetch}/${totalDataSources} datasources`);
            console.warn(`[Synchronizer] Skipped ${nbSkip}/${totalDataSources} datasources`);
            if((nbFetch + nbSkip) === totalDataSources) {
                console.warn('Starting Replay Algorithm...');
                this.processData();
                this.onStart();
            }
        }
    }

    checkEnd() {
        if (this.getCurrentTimestamp() > this.endTimestamp) {
            this.onEnd();
            this.reset();
        }
    }

    reset() {
        console.log('reset synchronizer algo')
        this.close();
        for (let currentDsId in this.dataSourceMap) {
            this.resetDataSource(currentDsId);
        }
        this.tsRun = undefined;
    }

    resetDataSource(datasourceId) {
        const currentDs = this.dataSourceMap[datasourceId];
        currentDs.dataBuffer = [];
        currentDs.status= Status.DISCONNECTED;
        currentDs.version = undefined;
        currentDs.skip = false;
    }

    removeDataSource(dataSourceId) {
        super.removeDataSource(dataSourceId);
        // looking for next start Timestamp
        let currentTimestamp = this.getCurrentTimestamp();
        let min, ds;
        for(let dsKey in this.dataSourceMap) {
            ds = this.dataSourceMap[dsKey];
            if(currentTimestamp >= ds.minTimestamp &amp;&amp; currentTimestamp &lt;= ds.maxTimestamp) {
                // continue because this datasource is in the current range
                return;
            } else {
                // otherwise
                // looking for next range and reset algo
                if(!min) {
                    min = ds.minTimestamp;
                } else if(ds.minTimestamp &lt; min) {
                    min = ds.minTimestamp;
                }
            }
        }
    }

    setEndTimestamp(maxTimestamp) {
        this.endTimestamp = maxTimestamp;
    }
    setTimeRange(startTimestamp, endTimestamp, replaySped) {
        this.replaySpeed = replaySped;
        this.startTimestamp = startTimestamp;
        this.endTimestamp = endTimestamp;
        this.clockTimeRef = performance.now();
        this.reset();
        this.checkStart();
    }

    onEnd() {}
    onStart() {}
}

export default DataSynchronizerAlgoReplay;
</code></pre>
        </article>
    </section>




    </div>
</div>


<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
